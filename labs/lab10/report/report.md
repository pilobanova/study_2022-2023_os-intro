---
## Front matter
title: "Отчет по лабораторной работе №10"
subtitle: "Дисциплина: операционные системы"
author: "Лобанова Полина Иннокентьевна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Изучить основы программирования в оболочке ОС UNIX/Linux. Научиться писать небольшие командные файлы.

# Выполнение лабораторной работы

1. Создадим необходимые файлы, чтобы в дальнейшем их заполнить.

![*Создание файлов.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/1.png){#fig:001 width=70%}

2. Напишем скрипт, который при запуске будет делать резервную копию самого себя в другую директорию backup в нашем домашнем каталоге. При этом файл должен архивироваться одним из архиваторов на выбор zip, bzip2 или tar. 

![*Текст командного файла.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/2.png){#fig:002 width=70%}

![*Результат.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/3.png){#fig:003 width=70%}

3. Напишем пример командного файла, обрабатывающего любое произвольное число аргументов командной строки, в том числе превышающее десять. Например, скрипт будет последовательно распечатывать значения всех переданных аргументов.

![*Текст командного файла.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/4.png){#fig:004 width=70%}

![*Результат.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/5.png){#fig:005 width=70%}

4. Напишем командный файл — аналог команды ls (без использования самой этой команды и команды dir) так, чтобы он выдавал информацию о нужном каталоге и выводил информацию о возможностях доступа к файлам этого каталога.

![*Текст командного файла.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/6.png){#fig:006 width=70%}

![*Результат.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/7.png){#fig:007 width=70%}

5. Напишем командный файл, который получает в качестве аргумента командной строки формат файла (.txt, .doc, .jpg, .pdf и т.д.) и вычисляет количество таких файлов в указанной директории. Путь к директории также передаётся в виде аргумента командной строки.

![*Текст командного файла.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/8.png){#fig:008 width=70%}

![*Результат.*](/home/pilobanova/work/study/2022-2023/Операционные системы/os-intro/labs/lab10/report/image/лаба10с2/9.png){#fig:009 width=70%}

# Контрольные вопросы

1.	Объясните понятие командной оболочки. Приведите примеры командных оболочек. Чем они отличаются?

Командный процессор (командная оболочка, интерпретатор команд shell) — это программа, позволяющая пользователю взаимодействовать с операционной системой компьютера. В операционных системах типа UNIX/Linux наиболее часто используются следующие реализации командных оболочек:
• оболочка Борна (Bourne shell или sh) — стандартная командная оболочка UNIX/Linux, содержащая базовый, но при этом полный набор функций;
• С-оболочка (или csh) — надстройка на оболочкой Борна, использующая С-подобный синтаксис команд с возможностью сохранения истории выполнения команд;
• оболочка Корна (или ksh) — напоминает оболочку С, но операторы управления программой совместимы с операторами оболочки Борна;
• BASH — сокращение от Bourne Again Shell (опять оболочка Борна), в основе своей совмещает свойства оболочек С и Корна (разработка компании Free Software Foundation).

2.	Что такое POSIX?

POSIX (Portable Operating System Interface for Computer Environments) — набор стандартов описания интерфейсов взаимодействия операционной системы и прикладных программ

3.	Как определяются переменные и массивы в языке программирования bash?

mark=/usr/andy/bin
Данная команда присваивает значение строки символов /usr/andy/bin переменной mark типа строкасимволов.
Для создания массива используется команда set с флагом -A. За флагом следует имя переменной, а затем список значений, разделённых пробелами. Например,

set -A states Delaware Michigan "New Jersey"

4.	Каково назначение операторов let и read?

Команда let является показателем того, что последующие аргументы представляют собой выражение, подлежащее вычислению. Команда read позволяет читать значения переменных со стандартного ввода

5.	Какие арифметические операции можно применять в языке программирования bash?

Простейшими математическими выражениями являются сложение (+), вычитание (-), умножение (*), целочисленное деление (/) и целочисленный остаток от деления (%).

6.	Что означает операция (( ))?

Для облегчения программирования можно записывать условия оболочки bash в двойные скобки — (( )).

7.	Какие стандартные имена переменных Вам известны?

Переменные PS1 и PS2 предназначены для отображения промптера командного процессора. PS1 — это промптер командного процессора, по умолчанию его значение равно символу $ или #. Если какая-то интерактивная программа, запущенная командным процессором, требует ввода, то используется промптер PS2. Он по умолчанию имеет значение символа >. Другие стандартные переменные:
• HOME — имя домашнего каталога пользователя. Если команда cd вводится без аргументов, то происходит переход в каталог, указанный в этой переменной.
• IFS — последовательность символов, являющихся разделителями в командной строке,например, пробел, табуляция и перевод строки (new line).
• MAIL — командный процессор каждый раз перед выводом на экран промптера проверяет содержимое файла, имя которого указано в этой переменной, и если содержимое этого файла изменилось с момента последнего ввода из него, то перед тем как вывести на терминал промптер, командный процессор выводит на терминал сообщение You have mail (у Вас есть почта).
• TERM — тип используемого терминала.
• LOGNAME — содержит регистрационное имя пользователя, которое устанавливается автоматически при входе в систему.

8.	Что такое метасимволы?

Такие символы, как ’ < > * ? | ” &, являются метасимволами и имеют для командного процессора специальный смысл

9.	Как экранировать метасимволы?

Снятие специального смысла с метасимвола называется экранированием метасимвола. Экранирование может быть осуществлено с помощью предшествующего метасимволу символа , который, в свою очередь, является метасимволом.

10.	Как создавать и запускать командные файлы?

Командный файл можно создать с помощьб какого-либо редактора, затем сделать его исполняемым и запустить его из терминала, введя “./название файла”.

11.	Как определяются функции в языке программирования bash?

С помощью ключевого слова function.

12.	Каким образом можно выяснить, является файл каталогом или обычным файлом?

Вводим команду ls -lrt и если первым в правах доступа стоит d то это каталог. Иначе это файл

13.	Каково назначение команд set, typeset и unset?

Для создания массива используется команда set с флагом -A. Если использовать typeset -i для объявления и присвоения переменной, то при последующем её применении она станет целой. Изъять переменную из программы можно с помощью команды unset.

14.	Как передаются параметры в командные файлы?

При вызове командного файла на выполнение параметры ему могут быть переданы точно таким же образом, как и выполняемой программе. С точки зрения командного файла эти параметры являются позиционными. Символ $ является метасимволом командного процессора. Он используется, в частности, для ссылки на параметры, точнее, для получения их значений в командном файле. В командный файл можно передать до девяти параметров.
• $* — отображается вся командная строка или параметры оболочки;
• $? — код завершения последней выполненной команды;
• $$ — уникальный идентификатор процесса, в рамках которого выполняется командный процессор;
• $! — номер процесса, в рамках которого выполняется последняя вызванная на выполнение в командном режиме команда;
• $- — значение флагов командного процессора;
• ${#} — возвращает целое число — количество слов, которые были результатом $;
• ${#name} — возвращает целое значение длины строки в переменной name;
• ${name[n]} — обращение к n-му элементу массива;
• ${name[*]} — перечисляет все элементы массива, разделённые пробелом;
• ${name[@]} — то же самое, но позволяет учитывать символы пробелы в самих переменных;
• ${name:-value} — если значение переменной name не определено, то оно будет заменено на указанное value;
• ${name:value} — проверяется факт существования переменной;
• ${name=value} — если name не определено, то ему присваивается значение value;
• ${name?value} — останавливает выполнение, если имя переменной не определено, и выводит value как сообщение об ошибке;
• ${name+value} — это выражение работает противоположно ${name-value}. Если переменная определена, то подставляется value;
• ${name#pattern} — представляет значение переменной name с удалённым самым коротким левым образцом (pattern);
• ${#name[*]} и ${#name[@]} — эти выражения возвращают количество элементов в массиве name.

# Вывод

Я изучила основы программирования в оболочке ОС UNIX/Linux и научилась писать небольшие командные файлы.

